"""
simple_oauth_passlib.py is fairly the same as oauth_passlib_advanced.py.
The only major difference is that in the former we were generating the token ourselves, but in the former, it is a JWT
generated by the python jose library, and it is signed.
In the fpr,er, token verification was done by counter checking the token (which is a hash of username and password) against
the username and hashed password of user stored in the db.
In the latter, what we're doing to verify it is using the jose library to assert that the token was signed by us. If the
token was signed by someone else, but it still contains the same data, then the assertion would fail. We're using a secret
key to sign the token. A third party can't possibly (in an ideal security situation) know what this secret key is, so they
won't be able to sign the token using our key. Only tokens signed by us (we the originators of the token) will be allowed
to access resources that required said tokens.
Information like username (with key 'sub') is also recorded within the JWT, so while doing requests, you don't have to
explicitly and repeatedly pass in such info through path or query parameters, since they are contained in the JWT which
is itself contained in the header of the request.

JWT FTW !!!
"""

import os
from fastapi import FastAPI, Depends, HTTPException, Request, Response, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from datetime import datetime, timedelta
from pydantic import BaseModel, Field

from typing import Annotated, Callable

# jwt is imported from jose. make sure python-jose[cryptography] is installed in pip
from jose import jwt, JWTError, ExpiredSignatureError
from simple_oauth_passlib import Journal
from passlib.context import CryptContext


# load secret key and algo from environment. do this for security - don't store keys in code.
# Run this command in cmd to set env vars
#   export <key_name>=<key_here>
API_KEY = os.environ['X_API_KEY']
API_KEY_ALGO = os.environ['X_API_KEY_ALGO']
API_KEY_TTL = 300

passlib_crypt_context = CryptContext(schemes=['bcrypt'], deprecated='auto')
oauth2 = OAuth2PasswordBearer(tokenUrl='access-token')


def get_token_expiry(ttl: int = API_KEY_TTL) -> datetime:
    # use utc time to get current universal time, and then set the expiry date of a token by adding the timedelta.
    # in this case it is 300 seconds (5 minutes)
    return datetime.utcnow() + timedelta(seconds=ttl)


class AccessToken(BaseModel):
    """
    Helper class for generating access token.
    'sub' and 'exp' are fields to be used in the JWT.
        sub - refers to something like a username. The important thing to have in mind is that the sub key should have a
            unique identifier across the entire application, and it should be a string.
        exp - refers to the expiry time of the token
    """

    sub: str
    exp: datetime = Field(default_factory=get_token_expiry)

    def generate(self):
        # first arg to jwt.encode is the payload dict, next is the api key, and next is the algorithm
        token = jwt.encode(self.model_dump(), API_KEY, API_KEY_ALGO)
        return {    # remember to use the keys exactly as defined by oauth standards
            "access_token": token,
            "token_type": "bearer"
        }


app = FastAPI()

allowed_origins = [
    'http://localhost:8000'
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["GET"],
    allow_headers=["*"],
)


@app.middleware('http')
async def http_middleware(request: Request, call_next: Callable):
    from time import time

    now = lambda: round(time() * 1000)
    curr_time = now()

    response: Response = await call_next(request)
    response.headers['X-Proc-Time'] = f"{now() - curr_time} milliseconds"
    return response


async def send_email(username: str, email: str):
    import time
    time.sleep(7)
    print(f"Email to {username} <{email}>: thanks for your journal. Add more entries soon xoxo")


@app.post('/journal', response_model_include={'username'})
async def insert_journal(journal: Journal, tasks: BackgroundTasks) -> Journal:
    Journal.add_to_db(journal)
    if journal.email is not None:
        tasks.add_task(send_email, journal.username, journal.email)
    return journal


@app.post('/access-token')
async def get_access_token(credentials: Annotated[OAuth2PasswordRequestForm, Depends()]):
    username = credentials.username
    password = credentials.password

    journal = Journal.get(username)

    if not journal:
        raise HTTPException(status_code=404, detail='Journal not found')
    if not password or not passlib_crypt_context.verify(password, journal.password):
        raise HTTPException(status_code=402, detail='Invalid credentials')

    # in simple_oauth_passlib.py, we were generating the access token ourselves by hashing the username and password.
    # in this case, we're generating the access token using JWT. only the username is the personally identifying
    # information stored in the JWT.
    access_token = AccessToken(sub=username)
    return access_token.generate()


@app.get('/login-page')
def get_login_page():
    with open('page.html', 'r') as page:
        return Response(page.read(), media_type='text/html')


@app.get('/journal', response_model_exclude={'password'})
async def get_journal(token: Annotated[str, Depends(oauth2)]) -> Journal:
    CredentialsError = HTTPException(status_code=401, detail='Invalid authorization', headers={'WWW-Authenticate': 'Bearer'})

    try:
        # decoding the token is fairly the same process as encoding it.
        # a little change (at least what i noticed from the tutorials) is that algorithms is passed as a list (even if
        # it's only one algorithm), but still params are as follows: token, key, algo
        token = jwt.decode(token, API_KEY, algorithms=[API_KEY_ALGO])
        username = token.get('sub')     # this info is contained within the claims of the JWT.

        if username is None:
            raise CredentialsError

        journal = Journal.get(username)

        if journal is None:
            raise CredentialsError

        return journal
    except ExpiredSignatureError:
        # error thrown when the JWT expires. in that case, the client will have to request a new token.
        # you can return information in the http exception that will hint the client code that it will have to request
        # a new token.
        raise HTTPException(status_code=401, detail="Expired token")
    except JWTError:
        raise CredentialsError
